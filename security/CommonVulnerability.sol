// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract VulnerableToken{
    //This contract is vulnerable to overflow/underflow

    mapping(address => uint) public balances;

    function transfer (address to, uint amount) public {
        require(balances[msg.sender] >= amount, "insufficient balance");

        balances[msg.sender] -= amount; //potential underflow
        balances[to] += amount; //potential underflow
    }
}

//Timestamp dependence

contract TimeAuction{
    uint public autionTime;

    function bid() public payable {
        require(block.timestamp < autionTime, "Not allowed");
    }
}


//tx.origin for authentication

contract VulnerableWallet{
    address public owner;

    constructor(){
        owner = msg.sender;
    }

    function transfer (uint amount, address payable recipient) public {
        require(tx.origin == owner, "Not allowed");
        recipient.transfer(amount);
    }
}

//DelegateCall to untrusted callee

contract Vulnerable{
    address public owner;

    function delegate(address _contract, bytes memory _data) public {
        (bool success, ) = _contract.delegatecall(_data);
        require(success, "Call failed");
    }
}

//Uninitializeed storage pointers

contract Vulnerable2{
    uint[] public myArray;

    function vulnerableFunction() public {
        uint[] storage pointer;
        // pointer.push(1);
        //This modifies myArray!
    }
}

// To protect against these and other vulnerabilities, consider these best practices:

// Use the latest stable Solidity version.
// Employ static analysis tools like Slither or MythX.
// Follow well-established patterns and use audited libraries like OpenZeppelin.
// Always have your contracts professionally audited before deploying to mainnet.
// Implement comprehensive test suites, including property-based tests.